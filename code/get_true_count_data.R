#install.packages('tidyverse')
#install.packages('tigris')
#install.packages('censusapi')
#install.packages('sf')
#install.packages('mapview')
#install.packages('rjson')


library(tidyverse)
library(tigris)
library(censusapi)
library(sf)
library(mapview)
library(rjson)


## Reformating the visitor_home_cbgs data
expandOrigins <- function(patterns_data)
{
  
  expanded_patterns <- NULL
  
  #Loop over each row so that we can convert each row to multiple rows, one for each origin census block group of visitors.
  for(row in 1:nrow(patterns_data)){
    
    #If no recorded blockgroup, then just save as one row with no origin_census_block_group.   
    if(patterns_data$visitor_home_cbgs[row] == "{}") {
      
      data_row <- 
        data.frame(
          placekey = patterns_data$placekey[row],
          origin_census_block_group = NA, #origin block group is not available.
          origin_raw_visitor_counts_high = patterns_data$raw_visitor_counts[row],
          origin_raw_visitor_counts_low = patterns_data$raw_visitor_counts[row]
        )
      
    } 
    # Else, need to unpack the JSON dictionary.
    else {
      #Unpack, unlist, rename.
      json <- 
        patterns_data$visitor_home_cbgs[row] %>% 
        fromJSON() %>% 
        unlist() %>% 
        as.data.frame() %>% 
        rownames_to_column() %>% 
        rename(
          origin_census_block_group = "rowname",
          origin_raw_visitor_counts_high = "."
        ) %>% 
        mutate( # Dealing with the 2-4 visitor issue
          origin_raw_visitor_counts_low =
            ifelse(
              origin_raw_visitor_counts_high == 4,
              2,
              origin_raw_visitor_counts_high
            )
        )
      
      #Compute the unrecorded raw visitors by subtracting blockgroup-mapped origin_raw_visitor_counts from raw_visitor_counts. Special cases need to be considered because of the 2-4 visitor issue
      if(patterns_data$raw_visitor_counts[row] > sum(json$origin_raw_visitor_counts_high)){
        
        unrecorded_raw_visitor_counts_high <- 
          patterns_data$raw_visitor_counts[row] - sum(json$origin_raw_visitor_counts_high)
        
        unrecorded_raw_visitor_counts_low <-
          patterns_data$raw_visitor_counts[row] - sum(json$origin_raw_visitor_counts_low)
        
      } else {
        
        #In this rare case, there were enough origins overcounted as having 4 raw visitors that the total count for recorded origins exceeded that actual raw_visitor_count. We downscale all recorded origin visitor counts so that the sum of recorded origin visitor counts equals actual raw_visitor_count exactly.
        json$origin_raw_visitor_counts_high <-
          json$origin_raw_visitor_counts_high/sum(json$origin_raw_visitor_counts_high)*patterns_data$raw_visitor_counts[row]
        
        unrecorded_raw_visitor_counts_high <- 0
        
        unrecorded_raw_visitor_counts_low <-
          max((patterns_data$raw_visitor_counts[row] - sum(json$origin_raw_visitor_counts_low)),0)
        
      }
      
      #Add one more row which contains unrecorded raw_visitor_counts.
      data_row <- 
        json %>% 
        rbind(
          data.frame(
            origin_census_block_group = NA,
            origin_raw_visitor_counts_high = unrecorded_raw_visitor_counts_high,
            origin_raw_visitor_counts_low = unrecorded_raw_visitor_counts_low
          )
        ) %>% 
        mutate(
          placekey = patterns_data$placekey[row]
        )
      
    }
    #Put all the rows together.
    expanded_patterns <-
      expanded_patterns %>% 
      rbind(data_row)
  }
  
  #Join the rest of the patterns data using safegraph place id.
  expanded_patterns <-
    expanded_patterns %>% 
    left_join(patterns_data, by = 'placekey')
  
  return(expanded_patterns)
}

####################### Try again ##########################
normBG <- function(patterns, home_summary, sub_blockgroups = sample_tx_pop, total_pop_blockgroup = norm_tx_pop_blockgroup){
  
  #Expand and categorize visitors by origin_census_block_group.
  #Also join population and home summary data.
  patterns <- 
    expandOrigins(patterns) %>%
    left_join(home_summary, by = c('origin_census_block_group' = 'census_block_group')) %>%
    left_join(total_pop_blockgroup, by = 'origin_census_block_group')
  
  #To estimate number of visitors from unrecorded block groups, use the visitors-to-devices ratio generated by the aggregate recorded block groups.
  recorded_pop <-
    total_pop_blockgroup %>% 
    filter(
      origin_census_block_group %in% patterns$origin_census_block_group
    ) %>% 
    pull(pop) %>% 
    sum()
  
  #Compute total number of devices with recorded origin blockgroups.
  recorded_sg_pop <-
    home_summary %>% 
    filter(census_block_group %in% patterns$origin_census_block_group) %>% 
    pull(number_devices_residing) %>% 
    sum()
  
  #Compute ratio
  recorded_ratio <- recorded_pop/recorded_sg_pop
  #Use the above ratio for the raw visitors with the unrecorded origin blockgroups.
  
  patterns <-
    patterns %>% 
    mutate(
      origin_visitor_counts_high =
        ifelse(
          !is.na(origin_census_block_group),
          origin_raw_visitor_counts_high*pop/number_devices_residing,
          origin_raw_visitor_counts_high*recorded_ratio
        ),
      origin_visitor_counts_low =
        ifelse(
          !is.na(origin_census_block_group),
          origin_raw_visitor_counts_low*pop/number_devices_residing,
          origin_raw_visitor_counts_low*recorded_ratio
        )
    )
  
  #Finally get visit_counts by multiplying by ratio of raw visit:visitor ratio.
  patterns <- 
    patterns %>% 
    mutate(
      visit_counts_high = origin_visitor_counts_high*raw_visit_counts/raw_visitor_counts,
      visit_counts_low = origin_visitor_counts_low*raw_visit_counts/raw_visitor_counts
    )
  
  return(patterns)
}


### VARIABLES ####
pattern_data_path = 'sample_data'
home_data_path = 'new_home'
state_abb = 'TX'
state_code = '48'
counties <- c('Travis')
acs_year <- 2021


########## Test census data retrieval ########

#Get FIPS code
Texas_counties_FIP <- counties(state_abb, progress_bar=F) %>% 
  filter( NAME %in% counties) %>%
  pull(COUNTYFP)

#Get population
sample_tx_pop <-
  getCensus(
    name = "acs/acs1",
    vintage = acs_year,
    region = "county:*", 
    regionin = paste0("state:", state_code),
    vars = "B01003_001E"
  ) %>% 
  filter(county %in% Texas_counties_FIP) %>% 
  pull(B01003_001E) %>% #This is an ACS code for population counts.
  sum()

#get blockgroup FIPS code
tx_blockgroups <-
  counties %>%
  map(function(x){
    block_groups(state, x, progress_bar=F) %>%
      pull(GEOID)
  }) %>% 
  unlist()

#complete texas counties FIP
full_tx_counties_fips <-
  counties(state_abb, progress_bar=F) %>%
  pull(COUNTYFP)

norm_tx_pop_blockgroup <-
  full_tx_counties_fips %>% 
  map_dfr(function(x){
    getCensus(
      name = "acs/acs5",
      vintage = acs_year,
      region = "block group:*", 
      regionin = paste0("state:", state_code, "+county:", x),
      vars = "B01003_001E"
    )
  }) %>% 
  transmute(
    origin_census_block_group = paste0(
      state,county,tract,block_group
    ),
    pop = B01003_001E
  )

#Estimate true visitor counts based on census population for recorded block groups.

pattern_data <- read.csv(pattern_data_path)
home_data <- read.csv(home_data_path)
blockgroup_visits <- normBG(pattern_data, home_data)
head(blockgroup_visits)



